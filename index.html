<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Red Tails Seat Shuffler</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
}
body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  min-height: 100vh;
  position: relative;
  overflow: hidden;
  background: none;
}

/* Creator badge (top-left) */
.creator-badge {
  position: fixed;
  top: 12px;
  left: 12px;
  width: 100px;
  height: 100px;
  z-index: 6;
  display: inline-block;
  border-radius: 8px;
  overflow: visible;
}
.creator-badge img {
  width: 100px;
  height: 100px;
  object-fit: contain;
  display: block;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
.creator-badge .tooltip {
  position: absolute;
  top: 50%;
  left: 110px;
  transform: translateY(-50%) translateY(-6px);
  background: rgba(255,255,255,0.92);
  color: #111;
  padding: 8px 10px;
  border-radius: 6px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  font-size: 0.9rem;
  line-height: 1.2;
  max-width: 260px;
  white-space: normal;
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease, transform 180ms ease;
  z-index: 7;
}
.creator-badge:hover .tooltip {
  opacity: 1;
  transform: translateY(-50%) translateY(0);
  pointer-events: auto;
}
#watermark-container {
  position: fixed;
  top: 0; left: 0; width: 100vw; height: 100vh;
  z-index: 0;
  pointer-events: none;
  background: url('spitfire-watermark.png') repeat-x center center;
  background-size: auto 100vh;
  opacity: 0.5;
  display: block;
}
#watermark-img {
  display: none;
}

.table-window {
  background: rgba(240,240,240,0.95);
  border-radius: 18px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.12);
  padding: 2rem 2.5rem;
  margin-bottom: 1.5rem;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.center-content {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  width: 100vw;
}
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--gap);
  max-width: 480px;
  margin: 0 auto;
  z-index: 1;
  text-align: center;
  justify-content: center;
}
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
  margin-top: 14px;
  justify-content: center;
  align-items: center;
  width: 100%;
  z-index: 1;
}
button, label > span.btn {
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 8px;
  cursor: pointer;
  background: #e0fdff;
  min-width: 120px;
  font-size: 1rem;
  box-sizing: border-box;
  text-align: center;
  display: inline-block;
}
button:disabled { opacity: 0.6; cursor: not-allowed; }
#status { margin-top: 10px; color: #666; white-space: pre-line; }
.cursed { color: #C8102E; font-weight: 700; }
.file-input { display: none; }
:root { --gap: 8px; }
h1 {
  font-size: 2.2rem;
  margin-bottom: 10px;
  color: #C8102E;
  font-weight: 700;
  background: rgba(255,255,255,0.45);
  border-radius: 8px;
  padding: 0.5rem 1.5rem;
  display: inline-block;
  box-shadow: 0 0 16px 12px rgba(255,255,255,0.45);
}
.head { font-weight: 700; background: #e6e6e6; text-align: center; }
input[type="text"] { width: 100%; border: none; outline: none; text-align: center; font: inherit; }
</style>
</head>
<body>

<div id="watermark-container">
  <img src="spitfire-watermark.png" alt="watermark" id="watermark-img">
</div>
<a class="creator-badge" href="https://www.linkedin.com/in/sspaethe/" target="_blank" rel="noopener noreferrer">
  <img src="Blue Koala.png" alt="Creator: Sam Spaethe" />
  <div class="tooltip">Created by Sam Spaethe<br/>https://www.linkedin.com/in/sspaethe/</div>
</a>
<div class="center-content">
  <h1>Red Tails Seat Shuffler</h1>
  <div class="table-window">
    <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:8px;">
      <label style="display:flex; align-items:center; gap:6px;"><span>Rows:</span>
        <input type="number" id="rowCountInput" min="1" max="100" value="16" style="width:84px; text-align:center;" />
      </label>
      <button id="updateCountBtn">Update seat count</button>
    </div>

    <div class="grid" id="table">
      <div class="head">Name</div>
      <div class="head">New Position</div>
    </div>

    <div class="controls">
      <button id="shuffleBtn">Shuffle</button>
      <button id="downloadBtn">Download CSV</button>

      <input id="csvFile" class="file-input" type="file" accept=".csv" />
      <label for="csvFile"><span class="btn">Load CSV</span></label>

      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="soundToggle" checked />
        Sound
      </label>
    </div>

    <div id="status"><b>First Time Use: </b> Change the Name column numbers to the student names in those seats (i.e. if John is in the first seat, change 1 to John). 
      Then click shuffle to get the new positions.  Click Download csv and store it somewhere for next shuffle.
    <b>Subsequent Use:</b>  Click Load CSV and select the previously downloaded csv file to restore names and previous positions, then click Shuffle to get new positions.</div>
    </div>

    <audio id="player" src="randomizer.ogg" preload="auto"></audio>
  </div>
</div>

<script>
/** Config */
let N = 16;
const CSV_NAME = "shuffle.csv";
const ANIM_MS = 3650;
const TICK_MS = 100;

/** State */
let ids = Array.from({length: N}, (_, i) => i + 1);
let names = ids.map(String);
let currentPerm = ids.slice();
let animTimer = null;
let animUntil = 0;

/** Build UI rows dynamically for current N */
const table = document.getElementById('table');
const nameInputs = [];
const posCells = [];

function buildTable() {
  // clear existing
  table.innerHTML = '';
  nameInputs.length = 0;
  posCells.length = 0;

  const headName = document.createElement('div'); headName.className = 'head'; headName.textContent = 'Name';
  const headPos = document.createElement('div'); headPos.className = 'head'; headPos.textContent = 'New Position';
  table.appendChild(headName);
  table.appendChild(headPos);

  // ensure arrays are sized
  ids = Array.from({length: N}, (_, i) => i + 1);
  names = Array.from({length: N}, (_, i) => names[i] ?? String(i+1));
  currentPerm = Array.from({length: N}, (_, i) => currentPerm[i] ?? (i+1));

  for (let i = 0; i < N; i++) {
    const nameCell = document.createElement('div');
    const posCell  = document.createElement('div');

    const inp = document.createElement('input');
    inp.type = 'text';
    inp.value = names[i];
    inp.addEventListener('input', () => { names[i] = inp.value.trim() || String(i+1); });

    nameCell.appendChild(inp);
    table.appendChild(nameCell);
    table.appendChild(posCell);

    nameInputs.push(inp);
    posCells.push(posCell);
  }
}

/** Helpers */
function derangedShuffle(n = N, maxTries = 20000) {
  const base = Array.from({length:n}, (_, i) => i+1);
  let best = null, bestScore = Infinity;

  for (let t=0; t<maxTries; t++) {
    const perm = base.slice();
    // Fisher-Yates
    for (let i = perm.length-1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    // derangement check
    let fixed = false;
    for (let i=0;i<n;i++) if (perm[i] === base[i]) { fixed = true; break; }
    if (fixed) continue;

    const pos = new Map(perm.map((v, idx) => [v, idx]));
    let violations = 0;
    for (let k=1; k<n; k++) {
      if (Math.abs(pos.get(k) - pos.get(k+1)) === 1) violations++;
    }
    if (violations === 0) return perm;
    if (violations < bestScore) { bestScore = violations; best = perm; }
  }
  return best;
}

function updatePositions(perm) {
  const idToPos = new Map(perm.map((pid, idx) => [pid, idx + 1]));
  for (let row = 0; row < N; row++) {
    const pid = row + 1;
    const pos = idToPos.get(pid) ?? "";
    const cell = posCells[row];
    cell.className = "";
 
    // Deprecated cursed seat feature
 //   if (pos === 5) {
 //     cell.textContent = "CURSED SEAT (5)";
 //     cell.classList.add("cursed");
 //   } else {
      cell.textContent = String(pos);
 //   }
  }
}

function adjacencyViolations(perm) {
  const pos = new Map(perm.map((v, idx) => [v, idx]));
  let v = 0;
  for (let k=1; k<N; k++) if (Math.abs(pos.get(k) - pos.get(k+1)) === 1) v++;
  return v;
}

function setStatus(msg) {
  document.getElementById('status').textContent = msg;
}

/** Audio */
function playClick() {
  const enabled = document.getElementById('soundToggle').checked;
  if (!enabled) return;
  const audio = document.getElementById('player');
  audio.currentTime = 0;
  audio.play().catch(() => {/* ignore user-gesture/autoplay issues since button triggers it */});
}

/** Animation */
function startAnimation() {
  if (animTimer) return;
  // refresh names from inputs
  for (let i=0; i<N; i++) names[i] = nameInputs[i].value.trim() || String(i+1);

  playClick();
  setStatus("Scramblingâ€¦");
  const end = Date.now() + ANIM_MS;
  animUntil = end;
  document.getElementById('shuffleBtn').disabled = true;

  animTimer = setInterval(() => {
    if (Date.now() >= animUntil) {
      clearInterval(animTimer);
      animTimer = null;
      const final = derangedShuffle(N);
      currentPerm = final.slice();
      updatePositions(final);
      const score = adjacencyViolations(final);
      setStatus(score === 0 ? "Shuffle complete!" : `Done. ${score} adjacency violation(s) minimized.`);
      document.getElementById('shuffleBtn').disabled = false;
      return;
    }
    // lively intermediate permutation
    const perm = ids.slice();
    for (let i = perm.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    if (Math.random() < 0.25) {
      const i = Math.floor(Math.random()*N);
      let j = Math.floor(Math.random()*N);
      if (i === j) j = (j+1) % N;
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    updatePositions(perm);
  }, TICK_MS);
}

/** CSV I/O */
function toCSV(namesArr, perm) {
  const header = ["PermanentID","Name","ShuffledPosition","NameAtPosition"];
  const idToPos = new Map(perm.map((pid, idx) => [pid, idx+1]));
  const rows = [header.join(",")];
  for (let pid = 1; pid <= N; pid++) {
    const name = namesArr[pid-1];
    const pos = idToPos.get(pid) ?? "";
    const nameAtPos = (typeof pos === "number" && pos >=1 && pos <= N)
      ? namesArr[perm[pos-1]-1] : "";
    rows.push([pid, csvEscape(name), pos, csvEscape(nameAtPos)].join(","));
  }
  return rows.join("\n");
}
function csvEscape(s) {
  s = String(s ?? "");
  return (s.includes(",") || s.includes('"') || s.includes("\n"))
    ? `"${s.replace(/"/g, '""')}"`
    : s;
}
function downloadCSV() {
  const blob = new Blob([toCSV(names, currentPerm)], {type: "text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = CSV_NAME;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function parseCSV(text) {
  // Simple CSV parser for our expected columns
  const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
  if (lines.length === 0) return;

  // If CSV contains M data rows (excluding header), resize table to M so data isn't cut off
  const dataRows = Math.max(0, lines.length - 1);
  if (dataRows > 0) {
    N = dataRows;
    const rc = document.getElementById('rowCountInput');
    if (rc) rc.value = String(N);
  }

  const header = lines[0].split(",").map(h => h.trim().replace(/^"|"$/g,"").toLowerCase());
  const pidIdx = header.indexOf("permanentid") !== -1 ? header.indexOf("permanentid")
               : header.indexOf("id") !== -1 ? header.indexOf("id") : -1;
  const nameIdx = header.indexOf("name");
  const posIdx = ["shuffledposition","position","pos","shuffled_position","newposition","new_position","new position","nameatposition"].map(k => header.indexOf(k)).find(i => i !== -1);

  // Rebuild table now that N may have changed
  buildTable();

  const newNames = Array.from({length:N}, (_,i)=> String(i+1));
  let posToPid = {};

  for (let i=1; i<lines.length; i++) {
    const row = splitCSVLine(lines[i]);
    const get = (idx) => (idx >=0 && idx < row.length) ? row[idx] : "";
    const pidRaw = get(pidIdx);
    const nameRaw = get(nameIdx);
    const posRaw = get(posIdx);

    const parsedPid = Number.parseInt(pidRaw, 10);
    // fallback: use the CSV data-row index as the pid if permanent id missing/invalid
    const fallbackPid = i; // i starts at 1 for first data row
    const effectivePid = (Number.isFinite(parsedPid) && parsedPid >= 1) ? parsedPid : fallbackPid;

    const nm = (nameRaw || "").trim();
    if (effectivePid >=1 && effectivePid <= N && nm) {
      newNames[effectivePid-1] = nm;
    }

    const pos = Number.parseInt(posRaw, 10);
    if (Number.isFinite(pos) && pos >=1 && pos <= N && effectivePid >=1 && effectivePid <= N) {
      posToPid[pos] = effectivePid;
    }
  }

  names = newNames;
  for (let i=0;i<N;i++) nameInputs[i].value = names[i];

  if (Object.keys(posToPid).length === N) {
    currentPerm = Array.from({length:N}, (_,i)=> posToPid[i+1]);
    updatePositions(currentPerm);
    setStatus("Loaded CSV (names and exact positions).");
  } else {
    updatePositions(currentPerm);
    setStatus("Loaded CSV (names only).");
  }
}

function splitCSVLine(line) {
  const out = [];
  let curr = "";
  let inQuotes = false;
  for (let i=0;i<line.length;i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"') {
        if (line[i+1] === '"') { curr += '"'; i++; }
        else { inQuotes = false; }
      } else curr += ch;
    } else {
      if (ch === ',') { out.push(curr); curr = ""; }
      else if (ch === '"') inQuotes = true;
      else curr += ch;
    }
  }
  out.push(curr);
  return out;
}

/** Wire up controls */
document.getElementById('shuffleBtn').addEventListener('click', startAnimation);
document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
document.getElementById('csvFile').addEventListener('change', (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => parseCSV(String(reader.result || ""));
  reader.readAsText(file);
});

// Row count control wiring
document.getElementById('updateCountBtn').addEventListener('click', () => {
  const v = Number.parseInt(document.getElementById('rowCountInput').value, 10);
  if (!Number.isFinite(v) || v < 1 || v > 200) return setStatus('Invalid row count');
  N = v;
  // rebuild table and preserve names/perm as much as possible
  buildTable();
  updatePositions(currentPerm);
  setStatus(`Seat count updated to ${N}.`);
});

/** Initial render */
buildTable();
updatePositions(currentPerm);
</script>
</body>
</html>
